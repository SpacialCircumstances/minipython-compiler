use crate::ast::Ast;
use crate::name::{Name, NameStore};
use crate::lexer::{Token, Location, LexerError};
use crate::lexer::Token::*;

grammar<'input>(input: &'input str, names: &mut NameStore);

extern {
    type Location = Location;
    type Error = LexerError;

    enum Token<'input> {
        "input" => Input,
        "output" => Output,
        "," => Comma,
        "indent" => Indent,
        "unindent" => Unindent,
        "return" => Return,
        "def" => Def,
        ":" => Colon,
        "name" => Name(<&'input str>),
        "(" => OpenParen,
        ")" => CloseParen,
        "while" => While,
        "!=0" => NotEqualZero,
        "+=1" => PlusEqualOne,
        "-=1" => MinusEqualOne,
    }
}

pub Program: Vec<Ast> = Expr*;

Expr: Ast = {
    <Name> "+=1" => Ast::Incr { var_name: <> },
    <Name> "-=1" => Ast::Decr { var_name: <> },
    "return" <Name> => Ast::Return { name: <> }
};

Name: Name = "name" => names.register(<>);